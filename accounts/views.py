import os
import datetime
from django.shortcuts import render, HttpResponse

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.decorators import api_view, permission_classes
from rest_framework import status
from rest_framework.permissions import BasePermission, IsAuthenticated, SAFE_METHODS
from rest_framework import status
from django.contrib.auth.models import User

from accounts.models import Client,Employee,PushNotification,NotificationKeys
from .permissions import (
    get_permissions
)
from team.serializers import EmployeeGetSerializer
from .serializers import ProfileGetSerializer,PushNotificationSerializer

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_permission_access(request):
    user =User.objects.get(id=request.user.id)
    login_employee = Employee.objects.get(user=user)
    if request.method == 'GET':
        try:
            user = request.user
            logined_user = Employee.objects.get(user=user)
            permission =get_permissions(logined_user.user_type)
            return Response(permission)
        except Exception as E:
            return Response({'Error': str(E), 'app_data': 'No such a Client found '}, status=status.HTTP_400_BAD_REQUEST) 


@api_view(['GET','PATCH'])
@permission_classes([IsAuthenticated])
def get_profile(request):
    user =User.objects.get(id=request.user.id)
    login_employee = Employee.objects.get(user=user)
    if request.method == 'GET':
        try:
            serializer = EmployeeGetSerializer(login_employee,many=False)
            return Response(serializer.data)
        except Exception as E:
            return Response({'Error': str(E), 'app_data': 'No such a Client found '}, status=status.HTTP_400_BAD_REQUEST)

    if request.method == 'PATCH':
        try:
            if 'password' in request.data:
                if request.POST['password']!='':
                    user.set_password(request.POST['password'])
                    user.save()
            if 'username' in request.data:
                if request.POST['username']!='':
                    user.username =request.POST['username']
                    user.save()   
            if 'email' in request.data:
                if request.POST['email']!='':
                    user.email =request.POST['email']
                    user.save()  
            if 'name' in request.data:
                if request.POST['name']!='':
                    user.name =request.POST['name']
                    user.save()
            if 'dp' in request.data:
                    login_employee.dp=request.FILES['dp'] 
                    login_employee.save()
            serializer = EmployeeGetSerializer(login_employee,many=False)    
            return Response(serializer.data)       

        except Exception as E:
            return Response({'Error': str(E), 'app_data': 'Enter valid data '}, status=status.HTTP_400_BAD_REQUEST)        
     


@api_view(['POST','DELETE'])
@permission_classes([IsAuthenticated])
def push_notification(request):
    emp = Employee.objects.get(user=request.user)
    if request.method == 'POST':
        try:
            try:    
                request.POST._mutable = True
                request.POST['employee'] = emp.id
            except:
                return Response({'Error': 'Employee does not exist','app_data': 'Employee does not exist'}, status=status.HTTP_400_BAD_REQUEST) 
            if PushNotification.objects.filter(employee = emp).exists():
                push_notification_obj = PushNotification.objects.get(employee=emp)
                uploaded_keys = request.data.pop('keys')
                for i in uploaded_keys:
                    for existing_key in push_notification_obj.keys.all():
                        if existing_key.key == i:
                            return Response({'Error': 'Key  already exists ','app_data': 'Key is already Created'}, status=status.HTTP_400_BAD_REQUEST) 
                    push_notification_obj.keys.create(key=i)
                try:
                    request.POST._mutable = False
                except:
                    pass    
                return Response({'Success': 'Key is Created','app_data': 'Key is Created'}, status.HTTP_201_CREATED)    
            else:
                serializer = PushNotificationSerializer(data=request.data)
                if serializer.is_valid():
                    push_notification_obj  = serializer.save()
                    uploaded_keys = request.data.pop('keys')
                    for i in uploaded_keys:
                        push_notification_obj.keys.create(key=i)
                    try:
                        request.POST._mutable = False
                    except:
                        pass
                    return Response({'Success': 'Key generated by a new member','app_data': 'This key is created by a new member '}, status.HTTP_201_CREATED)

                else:
                    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as E:
            return Response({'Error': str(E), 'app_data': 'device id was not added'},status=status.HTTP_400_BAD_REQUEST)
    if request.method =='DELETE':
        try:
            device_id = request.POST['keys']
            key_obj = NotificationKeys.objects.get(key=device_id)
            key_obj.delete()
               
            return Response({'app_data':'Token removed ','dev_data':'token deleted'})        
                
        except Exception as E:
            return Response({'Error': str(E), 'app_data': 'no device found'},status=status.HTTP_400_BAD_REQUEST)
@api_view(['DELETE'])
@permission_classes([IsAuthenticated])
def push_notification_key_deletion(request,device_id):           
    if request.method =='DELETE':
            try:
                key_obj = NotificationKeys.objects.get(key=device_id)
                key_obj.delete()
                return Response({'app_data':'Token removed ','dev_data':'token deleted'})    
                    
            except Exception as E:
                return Response({'Error': str(E), 'app_data': 'no device found'},status=status.HTTP_400_BAD_REQUEST)

# import subprocess
# import time
# import os
# import dropbox
# from dropbox.files import WriteMode


# #Program to automate the process of backing up database weekly and saving to a cloud storage(Dropbox)
# #Requisites:
# #     1.Dropbox API Token
# #     2.PostgreSQL commands(pg_dump) should be set as PATH Evironment variable
# #     3.".pgpass" file should be kept in user's home directory with the format YOUR_HOST:YOUR_PORT:DB_NAME:USER_NAME:PASSWORD with 600 permission
# #           (refer : https://newfivefour.com/postgresql-pgpass-password-file.html)

# #-----Replace the token-----(Get it from DropBox)



# dbx = dropbox.Dropbox('N5BE5ehHKTUAAAAAAAAAATv5LtH6Lk8ymcIao57cBgpJdPEPnhV0RzIAQf8-Hn51')
# filename = time.strftime("Backup on %d-%m-%Y.sql")
# upload_location = f'/{filename}'

# #creating a file in the system to write data from database
# with open(filename, 'wb') as f:

#   #Calling subprocess popen method and passing "pg_dump" for dumping entire database
#   #Replace ezed with database name and Postgres with database username
#   #pg_dump enviro_localdb -U enviro_u -h localhost  -F c  ##enviro00
#   popen = subprocess.Popen('pg_dump enviro_localdb -U enviro_u -h localhost pgpassword ##enviro00    -F c', stdout=subprocess.PIPE, universal_newlines=True, shell= True)
#   print
#   for stdout_line in iter(popen.stdout.readline, ''):
#     f.write(stdout_line.encode('utf-8'))
  
#   popen.stdout.close()
#   popen.wait()

